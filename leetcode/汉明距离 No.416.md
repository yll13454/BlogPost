### 汉明距离

汉明距离是使用在数据传输差错控制编码里面的，汉明距离是一个概念，它表示两个（相同长度）字对应位不同的数量，我们以d（x,y）表示两个字x,y之间的汉明距离。对两个字符串进行异或运算，并统计结果为1的个数，那么这个数就是汉明距离。

就是将一个字符串变换成另外一个字符串所需要替换的字符个数。

例子

```
1011101 与 1001001 之间的汉明距离是 2。
2143896 与 2233796 之间的汉明距离是 3。
"toned" 与 "roses" 之间的汉明距离是 3。
```

### x^y

x = x ^ y。^表示异或运算，10011和11001异或将得到01011，也就是说每位同号结果则是0，异号则结果为1。

#### AND 位运算

按位and是以二进制的对应位做与运算，两个对应位都为1，结果的对应位才为1，否则为0
  a:0101B  b:1100B a & b 结果: 0100B
布尔运算是逻辑运算，两个条件都为True结果才为True,否则结果为False

#### i&1

表示i与1按位与，即i对应的二进制与1对应的二进制按位与运算。

复合赋值。a>>=b相当于 a = a >> b; 以此类推。

a>>=b 表示把二进制a右移b位。<<= 同上，只不过是左移赋值。

&= 是按位与之后赋值，^=是按位异或之后赋值，|=是按位或之后赋值。

- 方法一

code：

```tsx
function hanmingjuli(x:number,y:number):number{
	let timers:number = 0
	let mask:number = 0x01
	let dis:number = 0
	while(timers<31){
		if((x&mask)!==(y&mask)){
			dis++
		}
		mask>>1
		timers++
	}
	return dis
}
```

- 方法二(**不懂**)

> 思路：
>
> #### 布赖恩·克尼根算法
>
> 方法二是逐位移动，逐位比较边缘位置是否为 1。寻找一种更快的方法找出等于 1 的位数。
>
> 是否可以像人类直观的计数比特为 1 的位数，跳过两个 1 之间的 0。例如：10001000。
>
> 上面例子中，遇到最右边的 1 后，如果可以跳过中间的 0，直接跳到下一个 1，效率会高很多。
>
> 这是布赖恩·克尼根位计数算法的基本思想。该算法使用特定比特位和算术运算移除等于 1 的最右比特位。
>
> 当我们在 number 和 number-1 上做 AND 位运算时，原数字 number 的最右边等于 1 的比特会被移除。

![img](D:\笔记\leetcode\media\461_brian.png)

code

```js
var hammingDistance = function(x, y) {
    let v = x ^ y; // 异或：相同位为0，不同位为1
    let dis = 0;
    while (v) {
        v = v & (v - 1);
        ++dis;
    }
    return dis;
};
```

